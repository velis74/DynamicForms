{% verbatim %}
  <script type="text/x-template" id="df-table-template">
    <div>
      <df-modal :title="editDialogTitle" :setDialog="setEditModal" :size="data.dialog.size">
        <df-form-layout slot="body" :def="data.dialog" :uuid="data.uuid"/>
      </df-modal>
      <div class="card">
        <div class="card-header">{{ data.titles.table }}<div class="float-right"><df-actions :actions="actions.filter('HEADER')"></df-actions></div></div>
        <div class="card-body">
          <table class="table">
            <thead is="df-table-header" :columns="columns" v-on:change-order="changeOrder"></thead>
            <tbody is="df-table-body" :columns="columns" :row-properties="rowProperties" :rows="rows"
                   :loading="loading" :actions="actions"></tbody>
            <tfoot>
              <tr class="no-data-indicator" v-if="rows.length == 0 && !loading">
                <td :colspan="columns.length">{{ noDataString }}</td>
              </tr>
              <tr class="no-data-indicator" v-if="rows.length == 0 && loading">
                <td :colspan="columns.length"><div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div></td>
              </tr>
              <tr class="loading-indicator" v-if="rows.length > 0 && loading">
                <td :colspan="columns.length">
                  <div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>
                </td>
              </tr>
            </tfoot>
          </table>
        </div>
      </div>
    </div>
  </script>
{% endverbatim %}

<script>
  const DisplayMode = Object.freeze({
    // This enum is actually declared in dynamicforms.mixins.render.py
    SUPPRESS: 1,
    HIDDEN: 5,
    INVISIBLE: 8,
    FULL: 10,
  });

  class DFTableColumn {
    constructor(columnDef) {
      this._columnDef = columnDef;
    }

    get name() {
      return this._columnDef.name;
    }

    get label() {
      return this._columnDef.label;
    }

    get align() {
      return this._columnDef.align;
    }

    get table_classes() {
      return this._columnDef.table_classes;
    }

    get ordering() {
      return this._columnDef.ordering;
    }

    get visibility() {
      switch (this._columnDef.visibility) {
        case 1:
          return DisplayMode.SUPPRESS;
        case 5:
          return DisplayMode.HIDDEN;
        case 8:
          return DisplayMode.INVISIBLE;
        case 10:
          return DisplayMode.FULL;
        default:
          console.warn(`Table column came with visibility set to ${this._columnDef.visibility}, but we don't know` +
            ` that constant`)
          return DisplayMode.FULL;
      }
    }

    get isOrdered() {
      return this.ordering.includes('ordering');
    }

    get th_classes() {
      return (this.table_classes + ' ' + (this.isOrdered ? 'ordering' : '')).trim()
    }

    get isAscending() {
      return this.isOrdered && this.ordering.includes('asc');
    }

    get isDescending() {
      return this.isOrdered && this.ordering.includes('desc');
    }

    get isUnsorted() {
      return this.isOrdered && this.ordering.includes('unsorted');
    }

    /**
     * cycles field ordering 'asc' -> 'desc' -> 'unsorted'
     */
    get cycleOrdering() {
      return this.isAscending ? 'desc' : this.isDescending ? 'unsorted' : 'asc';
    }

    /**
     * sets column sort sequence and direction
     * @param direction: one of "asc", "desc" or "unsorted"
     * @param sequence: integer. if none is provided, existing sequence # will be used or 1 if column was unsorted
     */
    setSorted(direction, sequence) {
      if (sequence === undefined)
        sequence = this.orderIndex > 0 ? this.orderIndex : 1

      if (!this.isOrdered) {
        console.warn(`column $(this.name) is not orderable. Why are you trying to set its order direction?`)
      } else if (direction == 'asc' || direction == 'desc' || direction == 'unsorted') {
        this._columnDef.ordering = `ordering ${direction} ${direction == 'unsorted' ? '' : 'seg-' + sequence}`;
      } else {
        console.warn(`unknown sort direction "${direction}" for the column ${this.name}. not doing anything`);
      }
    }

    get ascDescChar() {
      if (!this.isOrdered) return '';
      else if (this.isAscending) return '\u25b2';
      else if (this.isDescending) return '\u25bc';
      else if (this.isUnsorted) return '\u2195';
      else return '';
    }

    get orderIndex() {
      if (!this.isOrdered) return 0;
      let ordrIdxMatch = /(?:seg-)(\d+)/.exec(this.ordering);
      return ordrIdxMatch != null ? Number(ordrIdxMatch[1]) : 0;
    }

    get orderIndexChar() {
      return this.orderIndex > 0 ? String.fromCharCode(0x2460 + this.orderIndex - 1) : '';
    }

    get render_params() {
      return this._columnDef.render_params || {};
    }
    get renderDecoratorComponentName() {
      if (this.render_params.table) {
        const tableDecorator = this.render_params.table;
        return tableDecorator.substr(0, 1) == '#' ? tableDecorator.substr(1) : '';
      }
      return null;
    }

    get renderDecoratorFunction() {
      if (this.render_params && this.render_params.table) {
        const tableDecorator = this.render_params.table;
        if (tableDecorator.substr(0, 13) == 'df-tablecell-') {
          // built-in decorator functions
          const decoratorFunction = tableDecorator.substr(13);
          switch (decoratorFunction) {
            case 'bool': return (row, column, value) => { return `<code>${value}</code>`; };
            case 'link': return (row, column, value) => { return `<a href="${value}">${value}</a>`; };
            case 'email': return (row, column, value) => {
              let nameOnly = value.includes('<') ? value.substr(0, value.indexOf('<')).trim(): value;
              return `<a href="mailto:${value}">${nameOnly}</a>`;
            };
            case 'ipaddr': return (row, column, value) => {
              const segments = value.split('.');
              if (segments.length == 4) {
                value = segments.map(x => {
                  let padding = x.length < 3 ? `<span style="visibility: hidden">${'000'.slice(x.length - 3)}</span>` : '';
                  return padding + x;
                }).join('.');
              }
              return `<code>${value}</code>`;
            };
            // DRF also formats simple lists, complex dicts / lists
            // DRF also parses ordinary strings to check if they are valid URLs(link), emails(email) or contain \n (pre)
          }
        }
        else {
          // Here we're expecting the decorator to either suggest we use a component or a globally accessible function
          // When component, name will start with #, e.g. #df-tablecell-float. This will instruct table body to render
          //   a component with this name
          // When a function, name will be in format module.submodule.submodule_n.function, e.g. myModule.formatEmail
          //   The above example will look for function in window['myModule']['formatEmail'] and call it.
          return tableDecorator.split('.').reduce((res, val) => res[val], window);
        }
      }
      // if special JS function for formatting data is not provided, we just format the data as plain text
      return (row, column, value) => { return value; };
    }
  }

  Vue.component('df-table', {
    template: `#df-table-template`,
    props: ['url', 'data'],
    data() {
      const self = this;
      return {
        rows: self.loadableRows(self.data.rows),
        columns: self.data.columns.map(c => new DFTableColumn(c)),
        actions: new ActionsHandler(self.data.actions, self.showModal),
        rowProperties: self.data['row-properties'],
        loading: false,
        noDataString: gettext('no data'),
        editModal: null,
        editDialogTitle: 'Test dialog',
      };
    },
    computed: {
      sortedColumns() {
        // list of columns
        return this.columns.filter(col => col.isOrdered && !col.isUnsorted)
          .map(col => { return {fieldName: col.name, direction: col.isAscending, index: col.orderIndex}; })
          .sort((a, b) => a.index - b.index);
      },
      orderingParam() { return this.sortedColumns.map(o => (o.direction === true ? '' : '-') + o.fieldName); },
    },
    mounted() {
      const self = this;
      let bodyColumnCss = "";
      this.data.columns.forEach(function (column, idx) {
        bodyColumnCss += `#list-${self.data.uuid} tbody tr td:nth-child(${idx + 1}) {
            text-align: ${column.align};
          }
          `
      });
      let styleTag = document.createElement('style');
      styleTag.appendChild(document.createTextNode(bodyColumnCss));
      document.head.appendChild(styleTag);
    },
    methods: {
      changeOrder(colIdx, sortDirection, sortSeq, clearAllOthers) {
        const orderChanged = this.columns[colIdx].orderIndex != sortSeq;
        this.columns.forEach(function (column, index) {
          if (index == colIdx) {
            column.setSorted(sortDirection, sortSeq);
          } else if (column.orderIndex > 0) {
            if (clearAllOthers) column.setSorted('unsorted');
            else if (orderChanged && column.orderIndex >= sortSeq) {
              column.setSorted(column.isAscending ? 'asc' : 'desc', column.orderIndex + 1);
            }
          }
        });
      },
      loadData() {
        const self = this;
        self.loading = true;
        window.setTimeout(() => {
          // if it takes more than 250ms to load the new records, clear existing ones.
          // don't do it before to reduce flicker
          if (self.loading)
            self.rows = []; // clear existing rows, we're making a full refresh
        }, 250);
        axios
          .get(this.url + '?ordering=' + self.orderingParam, {headers: {'x-viewmode': 'TABLE_ROW', 'x-pagination': 1}})
          .then(res => {
            // call api and set data as response, when data is set component is re-rendered
            self.data.rows = res.data;  // replace .next, .previous and .results
            self.rows = self.loadableRows(res.data);  // replace just the rows that are rendering in the component
          })
          .catch(function (err) { alert(err.data) })
          .then(function () { self.loading = false; });
      },
      loadableRows(rowsData) {
        const self = this;
        let res = [], next = null;
        if (rowsData && rowsData.results && rowsData.results.constructor == Array) {
          res = rowsData.results;
          next = rowsData.next;
        }
        let decorate = triggerRow => {
          res.getVisibilityHandler = rowId => {
            return rowId == triggerRow ? {callback: res.loadMoreRows, once: true} : false;
          }
        };
        decorate(res.length && next ? res[0]['id'] : null);
        res.loadMoreRows = (isVisible) => {
          if (!isVisible) return;
          self.loading = true;
          axios
            .get(self.data.rows.next, {headers: {'x-viewmode': 'TABLE_ROW', 'x-pagination': 1}})
            .then(res => {
              // first we map existing row ids to respective array indexes
              let idIndices = self.data.rows.results.reduce((ind, item, idx) => {
                ind[item['id']] = idx;
                return ind;
              }, {});
              res.data.results.map(item => {
                // then we iterate through results updating any existing entries and adding new ones
                let idIdx = idIndices[item['id']];
                if (idIdx) self.data.rows.results[idIdx] = item;
                else self.data.rows.results.push(item);
              });
              self.data.rows.next = res.data.next;  // replace next so we can load another set of rows
              // finally create a new loadableRows so that it will load new rows based on this result set
              decorate(res.data.results[0]['id']);
            })
            .catch(function (err) {
              console.log(err);
              alert(err.data);
            })
            .then(function () { self.loading = false; });
        }
        return res;
      },
      setEditModal(component) {
        this.editModal = component;
      },
      showModal(action, row) {
        if (action.name == 'edit') this.editDialogTitle = this.data.titles.edit + ' ' + row['id'];
        else if (action.name == 'add') this.editDialogTitle = this.data.titles.new;
        else this.editDialogTitle = 'unknown action ' + action.name + ', so stupid title';
        this.editModal.show();
      },
    },
    watch: {
      orderingParam(_newVal, _oldVal) {
        this.loadData();
      }
    }
  });
</script>