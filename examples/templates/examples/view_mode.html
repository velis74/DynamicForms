{% extends 'examples/base.html' %}
{% block head_extra %}
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios@0.21.1/dist/axios.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/vue-observe-visibility/dist/vue-observe-visibility.min.js"></script><!-- requires intersection polyfill -->

  <style>
    th.ordering {
      cursor:      pointer;
      user-select: none;
    }

    th.ordering > span.ordering > div.ordering-arrow {
      font-size:   125%;
      line-height: .8em; /* increase font size for the arrow */
      display:     inline-block; /* but do not allow it to affect line size */
    }

    tfoot tr.no-data-indicator td {
      text-align:       center;
      vertical-align:   middle;
      height:           10em;
      background-color: #00000020;  /* just darken a little */
    }

    tfoot tr.loading-indicator td {
      text-align: center;
    }

    .actions-holder {
      transform: scale(.75, .75);
      display:   inline-block;
      margin:    -.5em;
    }

    .actions-holder div:not(:first-child) {
      margin-left: .5em;
    }

    .ionicon {
      display: inline-block;
      height:  1.5em;
    }

    .actions-holder .btn :not(:first-child) {
      margin-left: .5em;
    }
  </style>
{% endblock %}
{% block title %}Render in template example{% endblock %}
{% block body %}

  <div id="app">
    {{ page_data }}
  </div>

  {% verbatim %}
  <script type="text/x-template" id="df-table-template">
    <div class="card">
      <div class="card-header">{{ data.title }}<div class="float-right"><df-actions :actions="actions.filter('HEADER')"></df-actions></div></div>
      <div class="card-body">
        <table class="table">
          <thead is="df-table-header" :columns="columns" v-on:change-order="changeOrder"></thead>
          <tbody is="df-table-body" :columns="columns" :row-properties="rowProperties" :rows="rows"
                 :loading="loading" :actions="actions"></tbody>
          <tfoot>
            <tr class="no-data-indicator" v-if="rows.length == 0 && !loading">
              <td :colspan="columns.length">{{ noDataString }}</td>
            </tr>
            <tr class="no-data-indicator" v-if="rows.length == 0 && loading">
              <td :colspan="columns.length"><div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div></td>
            </tr>
            <tr class="loading-indicator" v-if="rows.length > 0 && loading">
              <td :colspan="columns.length">
                <div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>
              </td>
            </tr>
          </tfoot>
        </table>
      </div>
    </div>
  </script>

  <script type="text/x-template" id="df-table-header-template">
    <thead>
    <tr>  <!-- v-bind="properties" -->
      <th is="df-table-header-col" v-for="(col, idx) in columns" :key="col.name"
          :column="col" :col-idx="idx" :num-sorted-cols="numSortedCols"></th>
    </tr>
    </thead>
  </script>

  <script type="text/x-template" id="df-table-header-col-template">
    <th :style="`text-align: ${column.align}`" :class="column.th_classes" @click="colClicked($event)"
    >{{ column.label }}
      <span v-if="column.isOrdered" class="ordering"
      ><div class="ordering-arrow">{{ column.ascDescChar }}</div>{{ column.orderIndexChar }}</span>
    </th>
  </script>

  <script type="text/x-template" id="df-table-body-template">
    <tbody>
    <tr is="df-table-body-row" v-for="row in rows" :key="row['id']" :row="row" :columns="columns" :actions="actions"
        :row-properties="rowProperties" v-observe-visibility="rows.getVisibilityHandler(row['id'])"/>
    </tbody>
  </script>

  <script type="text/x-template" id="df-table-body-row-template">
    <tr :key="row['id']" :style="row['df_control_data']['row_css_style']" v-bind="rowProps"
        @click="rowClick('ROW_CLICK')" @mouseup.right="rowClick('ROW_RIGHTCLICK')">
      <td v-for="(col, idx) in columns" :key="col.name">
        <df-actions v-if="['#actions-row_start', '#actions-row_end'].includes(col.name)" :key="row['id']"
                    :actions="actions.filter(col.name.substr(9).toUpperCase())" :row="row"></df-actions>
        <template v-else>{{ row[col.name] }}</template>
      </td>
    </tr>
  </script>

  <script type="text/x-template" id="df-actions-template">
  <div class="actions-holder">
    <div v-for="action in actions.list" class="btn btn-sm btn-info"
         @click.stop="actions.exec(action, row)"><IonIcon :key="action.icon" :name="action.icon"/><span class="d-none d-md-inline-block">{{ action.label }}</span></div>
  </div>
  </script>

  <script type="text/x-template" id="ionicon-template">
    <div class="float-left" :key="loaded_svg" v-if="loaded_svg" v-html="loaded_svg"></div>
  </script>
  {% endverbatim %}

  <script>
    const DisplayMode = Object.freeze({
      // This enum is actually declared in dynamicforms.mixins.render.py
      SUPPRESS: 1,
      HIDDEN: 5,
      INVISIBLE: 8,
      FULL: 10,
    });

    class DFTableColumn {
      constructor(columnDef) {
        this._columnDef = columnDef;
      }

      get name() {
        return this._columnDef.name;
      }

      get label() {
        return this._columnDef.label;
      }

      get align() {
        return this._columnDef.align;
      }

      get table_classes() {
        return this._columnDef.table_classes;
      }

      get ordering() {
        return this._columnDef.ordering;
      }

      get visibility() {
        switch (this._columnDef.visibility) {
          case 1:
            return DisplayMode.SUPPRESS;
          case 5:
            return DisplayMode.HIDDEN;
          case 8:
            return DisplayMode.INVISIBLE;
          case 10:
            return DisplayMode.FULL;
          default:
            console.warn(`Table column came with visibility set to ${this._columnDef.visibility}, but we don't know` +
                         ` that constant`)
            return DisplayMode.FULL;
        }
      }

      get isOrdered() {
        return this.ordering.includes('ordering');
      }

      get th_classes() {
        return (this.table_classes + ' ' + (this.isOrdered ? 'ordering' : '')).trim()
      }

      get isAscending() {
        return this.isOrdered && this.ordering.includes('asc');
      }

      get isDescending() {
        return this.isOrdered && this.ordering.includes('desc');
      }

      get isUnsorted() {
        return this.isOrdered && this.ordering.includes('unsorted');
      }

      /**
       * cycles field ordering 'asc' -> 'desc' -> 'unsorted'
       */
      get cycleOrdering() {
        return this.isAscending ? 'desc' : this.isDescending ? 'unsorted' : 'asc';
      }

      /**
       * sets column sort sequence and direction
       * @param direction: one of "asc", "desc" or "unsorted"
       * @param sequence: integer. if none is provided, existing sequence # will be used or 1 if column was unsorted
       */
      setSorted(direction, sequence) {
        if (sequence === undefined)
          sequence = this.orderIndex > 0 ? this.orderIndex : 1

        if (!this.isOrdered) {
          console.warn(`column $(this.name) is not orderable. Why are you trying to set its order direction?`)
        } else if (direction == 'asc' || direction == 'desc' || direction == 'unsorted') {
          this._columnDef.ordering = `ordering ${direction} ${direction == 'unsorted' ? '' : 'seg-' + sequence}`;
        } else {
          console.warn(`unknown sort direction "${direction}" for the column ${this.name}. not doing anything`);
        }
      }

      get ascDescChar() {
        if (!this.isOrdered) return '';
        else if (this.isAscending) return '\u25b2';
        else if (this.isDescending) return '\u25bc';
        else if (this.isUnsorted) return '\u2195';
        else return '';
      }

      get orderIndex() {
        if (!this.isOrdered) return 0;
        let ordrIdxMatch = /(?:seg-)(\d+)/.exec(this.ordering);
        return ordrIdxMatch != null ? Number(ordrIdxMatch[1]) : 0;
      }

      get orderIndexChar() {
        return this.orderIndex > 0 ? String.fromCharCode(0x2460 + this.orderIndex - 1) : '';
      }
    }

    class ActionsHandler {
      constructor(actions) {
        this.actions = actions;
        this.filterCache = {};  // contains cached .filter results
      }

      /**
       * returns list of action objects
       * @returns [Action]
       */
      get list() {
        return Object.values(this.actions);
      }

      /**
       * filters actions to include only those rendering at given position
       * @param position
       * @returns {ActionsHandler}
       */
      filter(position) {
        const self = this;
        if (self.filterCache[position] == undefined) {
          self.filterCache[position] = new ActionsHandler(
            Object.values(self.actions)
              .filter(action => action.position == position)
              .reduce((obj, item) => {
                const name = item.name;
                obj[name] = self.actions[name];
                return obj;
              }, {}));
        }
        return self.filterCache[position];
      }

      exec(action, row) {
        console.log(['executing action', JSON.parse(JSON.stringify(action)), JSON.parse(JSON.stringify(row))]);
      }
    }

    Vue.component('df-table', {
      template: `#df-table-template`,
      props: ['url', 'data'],
      data() {
        const self = this;
        return {
          rows: self.loadableRows(self.data.rows),
          columns: self.data.columns.map(c => new DFTableColumn(c)),
          actions: new ActionsHandler(self.data.actions),
          rowProperties: self.data['row-properties'],
          loading: false,
          noDataString: gettext('no data'),
        };
      },
      computed: {
        sortedColumns() {
          // list of columns
          return this.columns.filter(col => col.isOrdered && !col.isUnsorted)
              .map(col => { return {fieldName: col.name, direction: col.isAscending, index: col.orderIndex}; })
              .sort((a, b) => a.index - b.index);
        },
        orderingParam() { return this.sortedColumns.map(o => (o.direction === true ? '' : '-') + o.fieldName); },
      },
      mounted() {
        const self = this;
        let bodyColumnCss = "";
        this.data.columns.forEach(function (column, idx) {
          bodyColumnCss += `#list-${self.data.guid} tbody tr td:nth-child(${idx + 1}) {
            text-align: ${column.align};
          }
          `
        });
        let styleTag = document.createElement('style');
        styleTag.appendChild(document.createTextNode(bodyColumnCss));
        document.head.appendChild(styleTag);
      },
      methods: {
        changeOrder(colIdx, sortDirection, sortSeq, clearAllOthers) {
          const orderChanged = this.columns[colIdx].orderIndex != sortSeq;
          this.columns.forEach(function (column, index) {
            if (index == colIdx) {
              column.setSorted(sortDirection, sortSeq);
            } else if (column.orderIndex > 0) {
              if (clearAllOthers) column.setSorted('unsorted');
              else if (orderChanged && column.orderIndex >= sortSeq) {
                column.setSorted(column.isAscending ? 'asc' : 'desc', column.orderIndex + 1);
              }
            }
          });
        },
        loadData() {
          const self = this;
          self.loading = true;
          window.setTimeout(() => {
            // if it takes more than 250ms to load the new records, clear existing ones.
            // don't do it before to reduce flicker
            if (self.loading)
              self.rows = []; // clear existing rows, we're making a full refresh
          }, 250);
          axios
            .get(this.url + '?ordering=' + self.orderingParam, { headers: {'x-viewmode': 'TABLE_ROW', 'x-pagination': 1} })
            .then(res => {
              // call api and set data as response, when data is set component is re-rendered
              self.data.rows = res.data;  // replace .next, .previous and .results
              self.rows = self.loadableRows(res.data);  // replace just the rows that are rendering in the component
            })
            .catch(function (err) { alert(err.data) })
            .then(function () { self.loading = false; });
        },
        loadableRows(rowsData) {
          const self = this;
          let res = [], next = null;
          if (rowsData && rowsData.results && rowsData.results.constructor == Array) {
            res = rowsData.results;
            next = rowsData.next;
          }
          let decorate = triggerRow => {
            res.getVisibilityHandler = rowId => {
              return rowId == triggerRow ? {callback: res.loadMoreRows, once: true} : false;
            }
          };
          decorate(res.length && next ? res[0]['id'] : null);
          res.loadMoreRows = (isVisible) => {
            if (!isVisible) return;
            self.loading = true;
            axios
              .get(self.data.rows.next, { headers: {'x-viewmode': 'TABLE_ROW', 'x-pagination': 1} })
              .then(res => {
                // first we map existing row ids to respective array indexes
                let idIndices = self.data.rows.results.reduce((ind, item, idx) => { ind[item['id']] = idx; return ind; }, {});
                res.data.results.map(item => {
                  // then we iterate through results updating any existing entries and adding new ones
                  let idIdx = idIndices[item['id']];
                  if (idIdx) self.data.rows.results[idIdx] = item;
                  else self.data.rows.results.push(item);
                });
                self.data.rows.next = res.data.next;  // replace next so we can load another set of rows
                // finally create a new loadableRows so that it will load new rows based on this result set
                decorate(res.data.results[0]['id']);
              })
              .catch(function (err) { console.log(err); alert(err.data); })
              .then(function () { self.loading = false; });
          }
          return res;
        }
      },
      watch: {
        orderingParam(_newVal, _oldVal) {
          this.loadData();
        }
      }
    });
    Vue.component('df-table-header', {
      template: `#df-table-header-template`,
      props: ['columns'],
      data() { return {}; },
      computed: {
        numSortedCols() { return this.columns.filter(col => col.ordering.includes('seg-')).length; },
      },
      mounted() {},
      methods: {},
    });
    Vue.component('df-table-header-col', {
      template: `#df-table-header-col-template`,
      props: ['column', 'colIdx', 'numSortedCols'],
      data() {
        return {};
      },
      computed: {},
      mounted() {},
      methods: {
        colClicked(event) {
          const self = this;

          if (!self.column.isOrdered)
              // don't do anything if this column is not sortable
            return;

          if (event.altKey) {
            // Show dialog with sort order options
          } else if (event.ctrlKey && event.shiftKey) {
            // remove column from ordering
            self.column.setSorted('unsorted');
          } else if (event.ctrlKey) {
            // set column as first sorted column
            self.$parent.$emit('change-order', self.colIdx, self.column.isDescending ? 'desc' : 'asc', 1);
          } else {
            // Change segment sort direction (and add it to sort segments list if not already there)
            // if shift is pressed add segment to existing ones. if not, set this column as the only segment of sort
            let ordrIdx = self.column.orderIndex,
                oSeq = event.shiftKey ? (ordrIdx == 0 ? self.numSortedCols + 1 : ordrIdx) : 1,
                oDir = event.shiftKey ? (self.column.isAscending ? 'desc' : 'asc') : self.column.cycleOrdering;
            self.$parent.$emit('change-order', self.colIdx, oDir, oSeq, !event.shiftKey);
          }
        },
      }
    });
    Vue.component('df-table-body', {
      template: `#df-table-body-template`,
      props: ['columns', 'rows', 'rowProperties', 'loading', 'actions'],
      data() { return {}; },
      computed: {},
      mounted() {},
      methods: {
        rowPropsWithData(row) {
          return this.rowProperties.reduce(function (obj, val) {
            if (!['row_css_style', 'df_control_data', 'df_prev_id'].includes(val)) {
              obj['data-' + val] = row[val];
            }
            return obj;
          }, {});
        },
        renderRowColumn(row, col) {
          /* !!!!! remove !!!! */
          if (col.name == '#actions-row_start' || col.name == '#actions-row_end') {
            return `<df-actions :actions="filteredActions('${col.name.substr(9).toUpperCase()}')"></df-actions>`;
          }
          return row[col.name];
        },
        rowClick(position, row) {
          const self = this;
          const actions = self.actions.filter(position);
          actions.list.forEach(action => { actions.exec(action, row); });
        }
      },
    });

    Vue.component('df-table-body-row', {
      template: `#df-table-body-row-template`,
      props: ['columns', 'row', 'rowProperties', 'actions'],
      data() {
        return {
          rowProps: this.rowProperties.reduce(function (obj, val) {
            if (!['row_css_style', 'df_control_data', 'df_prev_id'].includes(val)) {
              obj['data-' + val] = row[val];
            }
            return obj;
          }, {})
        };
      },
      computed: {},
      mounted() {},
      methods: {
        rowClick(position) {
          const self = this;
          const actions = self.actions.filter(position);
          actions.list.forEach(action => { actions.exec(action, self.row); });
        },
      },
    });

    Vue.component('df-actions', {
      template: `#df-actions-template`,
      props: {
        actions: {},
        row: { default: null },
      },
      data() { return {}; },
      computed: {},
      mounted() {},
      methods: {},
    });
    Vue.component('IonIcon', {
      template: `#ionicon-template`,
      props: ['name'],
      data() {
        return {
          loaded_svg: '',
        };
      },
      computed: {},
      mounted() {
        const self = this, name = self.name;
        if (!window.cache_ionicon) { window.cache_ionicon = {}; }
        if (!name) {}
        else if (window.cache_ionicon[name]) {
          if (typeof window.cache_ionicon[name].then == 'function') {
            window.cache_ionicon[name].then(res => { self.loaded_svg = res.data; });
            self.loaded_svg = '&hellip;';
            return;
          }
          self.loaded_svg = window.cache_ionicon[name];
        }
        else {
          self.loaded_svg = '&hellip;';
          window.cache_ionicon[name] = axios.get('https://unpkg.com/ionicons@5.5.1/dist/svg/' + name + '.svg');
          window.cache_ionicon[name].then(res => { self.loaded_svg = window.cache_ionicon[name] = res.data; });
        }
      },
      methods: {},
    });
    const tableApp = new Vue({
      el: `#app`,
    });
  </script>

{% endblock %}