from datetime import date
from typing import List

from rest_framework.exceptions import ValidationError
from django.utils.translation import gettext_lazy as _

from dynamicforms import serializers, fields
from dynamicforms.mixins import F

from examples.enum_field import EnumField
from examples.models import CalendarRecurrence


class DaysField(fields.CharField):
    def to_internal_value(self, data: str):
        def parse_token(token):
            token = token.strip()
            if len(token.split(" ")) == 2:
                return token.split(" ")
            return token

        if len(data.split(",")):
            return [parse_token(token) for token in data.split(",")]
        return parse_token(data)

    def to_representation(self, value: list, row_data=None):

        return ", ".join(value)


class DaysValidator:
    message = _("Wrong input format")

    def __init__(self, message=None):
        self.message = message or self.message

    def __call__(self, value: list):
        def token_validation(token: str):
            if token is None:
                return
            token = token.strip()
            if len(token.split(" ")) == 2:
                d = token.split(" ")
                if d[0][:3].lower() not in (
                    "1st",
                    "fir",
                    "2nd",
                    "sec",
                    "3rd",
                    "thi",
                    "4th",
                    "fou",
                    "5th",
                    "fif",
                    "las",
                ) or d[1] not in ("mo", "tu", "we", "th", "fr", "sa", "su"):
                    raise ValidationError(self.message, code="value")
            if not token.isnumeric() and 1 <= int(token) <= 31:
                raise ValidationError(self.message, code="value")

        for token in value:
            token_validation(token)


class DatesField(fields.CharField):
    def to_internal_value(self, data):
        def parse_token(token):
            token = token.strip()
            if len([d for d in token.split(".") if d]) == 2:
                return [d for d in token.split(".") if d]
            return token

        return [parse_token(token) for token in data.split(",")]

    def to_representation(self, value, row_data=None):
        return ", ".join([".".join(token) for token in value])


class DatesValidator:
    message = _("Wrong input format")

    def __init__(self, message=None):
        self.message = message or self.message

    def __call__(self, value: List[List[str]]):
        def token_validation(token: List[str]):
            if len(token) != 2 or not all([d.isnumeric() for d in token]):
                raise ValidationError(self.message, code="value")
            day, month = [int(d) for d in token]
            days_in_month = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
            if not (0 < month <= 12 and day <= days_in_month[month]):
                raise ValidationError(self.message, code="value")

        for token in value:
            token_validation(token)


class RecurrenceSerializer(serializers.ModelSerializer):
    pattern = EnumField(CalendarRecurrence.Pattern)
    recur = fields.AutoGeneratedField(display=fields.DisplayMode.SUPPRESS)

    every = fields.IntegerField(
        allow_null=True,
        conditional_visibility=F("pattern").is_in(
            [CalendarRecurrence.Pattern.Daily, CalendarRecurrence.Pattern.Weekly]
        ),
        required=False,
    )
    weekdays = fields.MultipleChoiceField(
        allow_null=True,
        choices=dict(zip(("ho", "mo", "tu", "we", "th", "fr", "sa", "su"), range(8))),
        conditional_visibility=F("pattern") == CalendarRecurrence.Pattern.Weekly,
        required=False,
    )
    days = DaysField(
        allow_null=True,
        conditional_visibility=F("pattern") == CalendarRecurrence.Pattern.Monthly,
        required=False,
        validators=[DaysValidator()],
    )
    dates = DatesField(
        allow_null=True,
        conditional_visibility=F("pattern") == CalendarRecurrence.Pattern.Yearly,
        required=False,
        validators=[DatesValidator()],
    )

    def __init__(self, *args, **kwds):
        super().__init__(*args, **kwds)
        self.fields["id"].read_only = False  # https://stackoverflow.com/a/46525126/1760858

    def to_representation(self, instance, row_data=None):
        setattr(instance, "every", instance.recur.get("every", None))
        setattr(instance, "weekdays", instance.recur.get("weekdays", None))
        setattr(instance, "days", instance.recur.get("days", None))
        setattr(instance, "dates", instance.recur.get("dates", None))

        return super().to_representation(instance, row_data)

    def to_internal_value(self, data: dict):
        data = super().to_internal_value(data)
        data["recur"] = dict(
            every=data.pop("every", None),
            days=data.pop("days", None),
            dates=data.pop("dates", None),
            weekdays=data.pop("weekdays", None),
        )
        return data

    class Meta:
        model = CalendarRecurrence
        exclude = ()
